### 如果有多个切片指向了同一个底层数组，那么你认为应该注意些什么？

1. 对单个切片的修改会影响底层数组的元素，进而对其他切片产生影响
2. 对某个满切片进行append会使其脱离原底层数组

### 怎样沿用“扩容”的思想对切片进行“缩容”？

假使我们现在有切片 `num := []int{1,2,3,4,5}`
- 扩容：`append(num,newNum)`
- 缩容：`num = num[l:r]`

### map底层的哈希逻辑

详见这篇博客（自己写的）： **[My Blog](https://www.claran-blog.work/2025/10/30/Go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Amap%E7%9A%84%E5%BA%95%E5%B1%82%E5%93%88%E5%B8%8C%E9%80%BB%E8%BE%91/)**

### 函数真正拿到的参数值其实只是它们的副本，那么函数返回给调用方的结果值也会被复制吗？

- 在值类型传递时，函数返回值会被复制

- 在引用类型传递时，仅复制地址，不会复制底层数据

以下是经了解后查证的内容：
> 这种机制可以保证数据的隔离性，避免意外的数值更改
> 
> <br>
> 
> 在返回值过大时，编译器会进行**逃逸分析**优化这个过程：
> 
> 编译器会分析变量的生命周期是否超过函数作用域（直接理解为变量是否过大），选择直接在栈上分配或在堆上分配
> 
> 栈分配（默认）时，变量局部使用，不跨越函数便捷
> 
> 堆分配（逃逸）时，函数返回指针，同时会增加运行压力

### 了解container包中的其他容器，比如：`List和Element`

详见这篇博客（自己写的）：**[My Blog](https://www.claran-blog.work/2025/10/16/Go-%E5%B8%B8%E7%94%A8%E5%8C%85%E4%B8%8E%E5%87%BD%E6%95%B0/)**

### 寻找`testing.T`类型和`testing.B`类型外的其他方法？它们都是做什么用的？

详见这篇博客（自己写的）： **[My Blog](https://www.claran-blog.work/2025/10/24/Go-%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/)**
